r"""Visualisation tools."""

import matplotlib.gridspec as gridspec
import matplotlib.pyplot as plt
import numpy as np
import wandb
import xarray as xr

from typing import Dict, Optional, Sequence, Tuple

# isort: split
from poseidon.config import PATH_DATA, PATH_MASK, PATH_STAT
from poseidon.data.const import DATASET_VARIABLES_SURFACE, TOY_DATASET_VARIABLES_SURFACE
from poseidon.data.mappings import from_tensor_to_xarray
from poseidon.diagnostics.const import CMAPS_SURF, TRANSLATION, UNITS
from poseidon.diffusion.denoiser import PoseidonDenoiser
from poseidon.diffusion.sampler import LMSSampler
from poseidon.diffusion.schedulers import PoseidonNoiseScheduler
from poseidon.diffusion.tools import PoseidonTrajectoryWrapper


def visualize(
    denoiser: PoseidonDenoiser,
    dimensions: Tuple[int, int, int],
    variables: Optional[Sequence[str]] = None,
    region: Optional[Dict[str, Tuple[int, int]]] = None,
    wandb_mode: Optional[str] = "disabled",
) -> None:
    r"""Visualizes forecasts generated by the denoiser.

    Arguments:
        denoiser: A denoiser model d(xₜ) ≈ E[x | xₜ]
        variables: Variable names to retain from the preprocessed dataset.
        region: Region of interest to extract from the dataset.
        dimensions: Spatial dimensions of the trajectory (C, X, Y).
        wandb_mode: Wether to use Weights & Biases for logging or not.
    """

    forecast_size, trajectory_size, steps = (
        3,
        7,
        32,
    )

    # Wrapping the denoiser into a full trajectory model
    denoiser_wrapped = PoseidonTrajectoryWrapper(
        denoiser,
        dimensions=dimensions,
        blanket_size=denoiser.backbone.K,
    )

    sampler = LMSSampler(
        denoiser=denoiser_wrapped,
        schedule=PoseidonNoiseScheduler(),
        dimensions=dimensions,
        order=3,
    )

    trajectory = sampler.forward(
        trajectory_size=trajectory_size,
        forecast_size=forecast_size,
        steps=steps,
    )

    dataset = from_tensor_to_xarray(
        x=trajectory.cpu(),
        variables=variables,
        region=region,
    )

    forecasts, levels, trajectory_size, _, _ = (
        dataset.sizes["batch"],
        dataset.sizes["level"] if "level" in dataset.sizes else 1,
        dataset.sizes["trajectory"],
        dataset.sizes["latitude"],
        dataset.sizes["longitude"],
    )

    # Ground truth used as illustrations
    dataset_gt, mask_bs = (
        xr.open_zarr(PATH_DATA)
        .sel(time=slice("2020-01-01", "2020-12-31"))
        .isel(**region, time=np.linspace(0, 365, trajectory_size, dtype=int)),
        xr.open_zarr(PATH_MASK)["mask"].isel(**region),
    )

    # Rescaling the data
    ds_stats = xr.open_zarr(PATH_STAT).isel(level=region["level"])

    dataset, dataset_gt = (
        dataset * ds_stats.sel(statistic="std") + ds_stats.sel(statistic="mean"),
        dataset_gt * ds_stats.sel(statistic="std") + ds_stats.sel(statistic="mean"),
    )

    for v in dataset.data_vars:
        data, data_gt = (
            dataset[v],
            dataset_gt[v],
        )

        for l in range(levels):
            #
            # Security
            if v in TOY_DATASET_VARIABLES_SURFACE + DATASET_VARIABLES_SURFACE and l > 0:
                break

            # Surface variables do not have a level dimension
            x, x_gt, mask = (
                data.isel(level=l).values if "level" in data.sizes else data.values,
                data_gt.isel(level=l).values if "level" in data_gt.sizes else data_gt.values,
                mask_bs.isel(level=l).values,
            )

            # Hidding the land
            x[:, :, mask == 0] = np.nan

            fig = plt.figure(figsize=(26, 8))
            gs = gridspec.GridSpec(
                forecasts + 1,
                trajectory_size + 1,
                height_ratios=[1] + [1] * forecasts,
                width_ratios=[1] * trajectory_size + [0.1],
            )

            # --- Example Trajectory (First Row) ---
            for t in range(trajectory_size):
                q_min, q_max = np.nanquantile(x_gt[t], [0.05, 0.95])
                ax = fig.add_subplot(gs[0, t])
                im = ax.imshow(
                    x_gt[t],
                    cmap=CMAPS_SURF[v],
                    origin="lower",
                    vmin=q_min,
                    vmax=q_max,
                    aspect="auto",
                )
                ax.set_xticks([])
                ax.set_yticks([])
                if t == 0:
                    ax.set_ylabel("Examples", fontsize=10, labelpad=10)
                    ax.set_title(
                        f"{TRANSLATION[v]} ${UNITS[v]}$ | Level {l} = {data_gt.level.values[l]:.3f} [m]",
                        fontsize=12,
                    )

            # --- Forecasts (Rows) ---
            for f in range(forecasts):
                cbar_ax = fig.add_subplot(gs[f + 1, -1])
                for t in range(trajectory_size):
                    q_min, q_max = np.nanquantile(x[f, t], [0.05, 0.95])
                    ax = fig.add_subplot(gs[f + 1, t])
                    im = ax.imshow(
                        x[f, t],
                        cmap=CMAPS_SURF[v],
                        origin="lower",
                        vmin=q_min,
                        vmax=q_max,
                        aspect="auto",
                    )
                    ax.set_xticks([])
                    ax.set_yticks([])
                    if t == 0:
                        ax.set_ylabel(f"Forecast {f + 1}", fontsize=10, labelpad=10)

                # --- Colorbar for Forecasts ---
                cb = fig.colorbar(im, cax=cbar_ax)
                cb.ax.tick_params(labelsize=8)

            plt.subplots_adjust(hspace=0.2, wspace=0.05)

            # Logging
            if wandb_mode != "disabled":
                wandb.log({f"{TRANSLATION[v]}/Level {l}": wandb.Image(fig)})
            else:
                plt.show()
            plt.close(fig)
