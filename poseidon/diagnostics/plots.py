r"""Visualisation tools."""

import matplotlib.pyplot as plt
import numpy as np
import wandb
import xarray as xr

from typing import Dict, Optional, Sequence, Tuple

# isort: split
from poseidon.config import PATH_DATA, PATH_MASK
from poseidon.data.mappings import from_tensor_to_xarray
from poseidon.diagnostics.const import CMAPS_SURF, TRANSLATION
from poseidon.diffusion.denoiser import PoseidonDenoiser
from poseidon.diffusion.sampler import PoseidonEulerSampler


def visualize(
    denoiser: PoseidonDenoiser,
    variables: Optional[Sequence[str]] = None,
    region: Optional[Dict[str, Tuple[int, int]]] = None,
    wandb_mode: Optional[str] = "disabled",
) -> None:
    r"""Visualizes forecasts generated by the denoiser.

    Arguments:
        denoiser: A trained :class:`PoseidonDenoiser` model.
        variables: Variable names to retain from the preprocessed dataset.
        region: Region of interest to extract from the dataset.
        wandb_mode: Wether to use Weights & Biases for logging or not.
    """

    forecast_size, trajectory_size, steps = (
        4,
        7,
        256,
    )

    trajectory = PoseidonEulerSampler(denoiser).forward(
        trajectory_size=trajectory_size, forecast_size=forecast_size, steps=steps
    )

    dataset = from_tensor_to_xarray(
        x=trajectory.cpu(),
        variables=variables,
        region=region,
    )

    forecasts, levels, trajectory_size, _, _ = (
        dataset.sizes["batch"],
        4,
        dataset.sizes["trajectory"],
        dataset.sizes["latitude"],
        dataset.sizes["longitude"],
    )

    # Ground truth used as illustrations
    dataset_gt, mask_bs = (
        xr.open_zarr(PATH_DATA)
        .sel(time=slice("2020-01-01", "2020-12-31"))
        .isel(**region, time=np.linspace(0, 365, trajectory_size, dtype=int)),
        xr.open_zarr(PATH_MASK)["mask"].isel(
            latitude=region["latitude"], longitude=region["longitude"]
        ),
    )

    for v in dataset.data_vars:
        data, data_gt = (
            dataset[v],
            dataset_gt[v],
        )

        for l in range(levels):
            # Surface variables do not have a level dimension
            x, x_gt, mask = (
                data.isel(level=l).values if "level" in data.sizes else data.values,
                data_gt.isel(level=l).values if "level" in data_gt.sizes else data_gt.values,
                mask_bs.isel(level=l).values,
            )

            # Hidding the land
            x[:, :, mask == 0] = np.nan

            # Generating a plot
            fig, axes = plt.subplots(
                forecasts + 1,
                trajectory_size,
                figsize=(15, 10),
            )

            # Ensure axes is always 2D for consistent indexing
            axes = axes.reshape(forecasts + 1, trajectory_size)

            # Plot example trajectory (first row)
            for t in range(trajectory_size):
                q_min, q_max = np.nanquantile(x_gt[t], [0.05, 0.95])
                ax = axes[0, t]
                ax.imshow(x_gt[t], cmap=CMAPS_SURF[v], origin="lower", vmin=q_min, vmax=q_max)
                ax.set_xticks([])
                ax.set_yticks([])
                if t == 0:
                    ax.set_ylabel("Examples", fontsize=8)
                    ax.set_title(TRANSLATION[v] + " - Level " + str(l))

            # Plot forecast trajectories
            for f in range(forecasts):
                for t in range(trajectory_size):
                    q_min, q_max = np.nanquantile(x[f, t], [0.05, 0.95])
                    ax = axes[f + 1, t]
                    ax.imshow(x[f, t], cmap=CMAPS_SURF[v], origin="lower", vmin=q_min, vmax=q_max)
                    ax.set_xticks([])
                    ax.set_yticks([])
                    if t == 0:
                        ax.set_ylabel(f"Forecast {f + 1}", fontsize=8)

            plt.subplots_adjust(hspace=-0.85)
            plt.tight_layout()

            # Logging
            if wandb_mode != "disabled":
                wandb.log({f"{TRANSLATION[v]}/Level {l}": wandb.Image(fig)})
            else:
                plt.show()
            plt.close(fig)

            # Security - If surface variable, break
            if "level" not in data.dims:
                break
